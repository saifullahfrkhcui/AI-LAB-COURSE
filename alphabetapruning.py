# -*- coding: utf-8 -*-
"""alphabetapruning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iUmTbPo4KfascJoGbebYj5DHvzjW9Hgo
"""

# Represent the tree with dicts/lists to preserve labels and ordering.
root = {
    'B': {            # B is Min
        'D': [3, 5],  # D is Max
        'E': [6, 9]   # E is Max
    },
    'C': {            # C is Min
        'F': [1, 2],  # F is Max
        'G': [0, -1]  # G is Max (this subtree will be pruned)
    }
}

VISITED = []

def alphabeta(node, alpha, beta, maximizing, path="A"):
    # leaf as int
    if isinstance(node, int):
        VISITED.append((path, node, "leaf"))
        return node

    # dict -> named children preserving order
    if isinstance(node, dict):
        items = list(node.items())
    else:
        # list of children
        items = list(enumerate(node))

    if maximizing:
        value = -10**9
        for name, child in items:
            child_path = f"{path}->{name}"
            v = alphabeta(child, alpha, beta, False, child_path)
            value = max(value, v)
            alpha = max(alpha, value)
            if alpha >= beta:
                VISITED.append((f"{child_path} (prune_remaining_siblings)", None, "prune"))
                break
        return value
    else:
        value = 10**9
        for name, child in items:
            child_path = f"{path}->{name}"
            v = alphabeta(child, alpha, beta, True, child_path)
            value = min(value, v)
            beta = min(beta, value)
            if alpha >= beta:
                VISITED.append((f"{child_path} (prune_remaining_siblings)", None, "prune"))
                break
        return value

VISITED.clear()
result = alphabeta(root, alpha=-10**9, beta=10**9, maximizing=True, path="A")
print("Minimax result at A:", result)
print("Visited / pruned trace:")
for item in VISITED:
    print(item)